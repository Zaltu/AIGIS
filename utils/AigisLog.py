"""
Responsible for the logging environment used both by the core and by the plugins
that pipe their outputs to the core.
"""
import os
import logging
from collections import deque

from utils.LogUtils import _add_log_handlers, _plugin_file_name, CORE_LOG_LOCATION  #pylint: disable=no-name-in-module

LOG = logging.getLogger("AIGIS")
_add_log_handlers(LOG, os.path.join(os.path.dirname(__file__), "../log/core.log"))

class LogManager():
    """
    Maintainer class for all the logging instances generated by Aigis and her plugins.
    """
    loggers = {}
    def __init__(self):
        pass

    def getLogger(self, plugin):
        """
        Return a specific plugin's logger

        :param AigisPlugin plugin: the plugin

        :returns: the plugin's logger if it exists, or None
        :rtype: AigisLog
        """
        if plugin.id in self.loggers:
            return self.loggers[plugin.id]
        return None

    def getCoreLogger(self, corename):
        """
        Fetch a logger to be used for a core module.

        :param str corename: name of the core module. Generally module.__name__

        :returns: configured python logger
        :rtype: logging.logger
        """
        if corename in self.loggers:
            return self.loggers[corename]
        self.loggers[corename] = logging.getLogger(corename)
        _add_log_handlers(self.loggers[corename], CORE_LOG_LOCATION.format(corename=corename))
        return self.loggers[corename]

    def hook(self, plugin):
        """
        Generate an AigisLogger object to be used to hook into a plugin's output.
        Careful. This may open a file handler.

        :param AigisPlugin plugin: the plugin to generate a logger for

        :returns: the AigisLogger
        :rtype: AigisLogger
        """
        logger = AigisLogger(plugin)
        self.loggers[plugin.id] = logger
        return logger

    def cleanup(self):
        """
        Clean up all loggers registered in the LogManager
        """
        LOG.shutdown("Cleaning up registered loggers...")
        for logger in self.loggers:
            logger.cleanup()


class AigisLogger():
    """
    Substitute class for logging with funcitonality depending on the plugin type.

    Be warned that for the case of external processes whose stdout pipes we catch,
    we open a file handler that is not automatically closed. It is up to the plugin
    watchdog to cleanup internal systems should a plugin crash or otherwise terminate.

    :param AigisPlugin plugin: plugin for which to create the logger
    """
    filehandler = None
    logger = None
    log_file = None
    def __init__(self, plugin):
        self.log_file = _plugin_file_name(plugin)
        if plugin.type == "external-pipe":
            self.filehandler = open(self.log_file, 'a+')
        elif plugin.type in ["internal", "core"]:
            self.logger = logging.getLogger(plugin.name)
            _add_log_handlers(self.logger, self.log_file)

    def tail(self):
        """
        Fetch the last 5 logs of a certain plugin.

        :returns: last 5 or fewer logs in the log file.
        :rtype: list
        """
        try:
            with open(self.log_file, 'r') as f:
                endlogs = deque(f, 5)
            return endlogs
        except IOError:
            LOG.warning("File %s does not exist. Cannot tail.", self.log_file)

    def cleanup(self):
        """
        Make sure all relevent open IO pipes are closed.
        """
        if self.filehandler:
            self.filehandler.close()
